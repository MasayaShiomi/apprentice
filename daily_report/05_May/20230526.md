# 日報
- 5/26（金）

## 本日の目標（TODO目標/できるようになりたいこと）
- JavaScript
  - a.QUEST 6～10を終わらせる
- HTML/CSS
  - b.Webサイト部分模写を1hする。(目標:Webサイトを構造を把握する視点を養う。毎日新しい学びを1つ獲ること。)

## 学習時間（Hour）
- 【本日】6h
- 【今週(目標:35h)】月:5h 火:6h 水:9h 木:8h 金:6h 土:h 日:h
- 【前週まで】29h/32h/

## 目標振り返り（TODO進捗/できるようになりたいこと振り返り）
- a.未達(6,7まで完了) b.達成

## 詰まっていること（実現したいこと/現状/行ったこと/仮説）
- なし

<!-- ```
・実現したいこと
・現状
・行ったこと
・仮説
``` -->

## 学んだこと（新しい気付き、学び）
### VScode 拡張機能 Live Serverのインストール
[Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) 


### strict mode
JavaScriptにはstrict modeという実行モードが存在しています。 名前のとおり厳格な実行モードで、古く安全でない構文や機能が一部禁止されています。

### 実行コンテキスト: ScriptとModule
JavaScriptの実行コンテキストとして"Script"と"Module"があります。 コードを書く場合には、この2つの実行コンテキストの違いを意識することは多くありません。

"Script"の実行コンテキストは、多くの実行環境ではデフォルトの実行コンテキストです。 "Script"の実行コンテキストでは、デフォルトはstrict modeではありません。

"Module"の実行コンテキストは、JavaScriptをモジュールとして実行するために、ECMAScript 2015で導入されたものです。 "Module"の実行コンテキストでは、デフォルトがstrict modeとなり、古く安全でない構文や機能は一部禁止されています。 また、モジュールの機能は"Module"の実行コンテキストでしか利用できません。

### 変数`const`、`let`、`var`
`var`はもっとも古くからある変数宣言のキーワードですが、意図しない動作を作りやすい問題が知られています。 そのためECMAScript 2015で、`var`の問題を改善するために`const`と`let`という新しいキーワードが導入されました。

#### [ES2015] `const`
`const`キーワードでは、再代入できない変数の宣言とその変数が参照する値（初期値）を定義できます。

次のように、`const`キーワードに続いて`変数名`を書き、代入演算子（`=`）の右辺に変数の`初期値`を書いて変数を定義できます。

```
const 変数名 = 初期値;
```

#### [ES2015] `let`
`let`キーワードでは、値の再代入が可能な変数を宣言できます。  
`let`は`const`とは異なり、初期値を指定しない変数も定義できます。

#### `var`
`var`キーワードでは、値の再代入が可能な変数を宣言できます。 `var`の使い方は`let`とほとんど同じです。

#### `var`の問題点
`var`は`let`とよく似ていますが、`var`キーワードには同じ名前の変数を再定義できてしまう問題があります。また`var`には変数の巻き上げと呼ばれる意図しない挙動があり、`let`や`const`ではこの問題が解消されています。

### 変数名に使える名前のルール
1. 半角のアルファベット、`_`（アンダースコア）、`$`（ダラー）、数字を組み合わせた名前にする
2. 変数名は数字から開始できない
3. 予約語と被る名前は利用できない

```
let $; // OK: $が利用できる
let _title; // OK: _が利用できる
let jquery; // OK: 小文字のアルファベットが利用できる
let TITLE; // OK: 大文字のアルファベットが利用できる
let es2015; // OK: 数字は先頭以外なら利用できる
let 日本語の変数名; // OK: 一部の漢字や日本語も利用できる
```

```
let 1st; // NG: 数字から始まっている
let 123; // NG: 数字のみで構成されている
```

```
let let; // NG: `let`は変数宣言のために予約されているので利用できない
let if; // NG: `if`はif文のために予約されているので利用できない
```

### `const`は定数ではない
`const`は「再代入できない変数」を定義する変数宣言であり、必ずしも定数を定義するわけではありません。 定数とは、一度定義した名前（変数名）が常に同じ値を示すものです。
す（詳細は「[データ型とリテラル](https://jsprimer.net/basic/variables//../data-type/)」の章で解説します）。

```
// TEN_NUMBERという変数は常に10という値を示す
const TEN_NUMBER = 10;
```

しかし、JavaScriptではオブジェクトなども`const`宣言できます。 次のコードのように、オブジェクトという値そのものは、初期化したあとでも変更できます。

```
// `const`でオブジェクトを定義している
const object = {
    key: "値"
};
// オブジェクトそのものは変更できてしまう
object.key = "新しい値";
```

### 変数まとめ
`var`はほとんどすべてのケースで`let`や`const`に置き換えが可能です。 `const`は再代入できない変数を定義するキーワードです。再代入を禁止することで、ミスから発生するバグを減らすことが期待できます。 このため変数を宣言する場合には、まず`const`で定義できないかを検討し、できない場合は`let`を使うことを推奨しています。

### データ型
JavaScriptは動的型付け言語に分類される言語であるため、静的型付け言語のような**変数の型**はありません。 しかし、文字列、数値、真偽値といった**値の型**は存在します。 これらの値の型のことを**データ型**と呼びます。

### データ型を大きく分けると、**プリミティブ型**と**オブジェクト**の2つに分類されます。

プリミティブ型（基本型）は、真偽値や数値などの基本的な値の型のことです。 プリミティブ型の値は、一度作成したらその値自体を変更できないというイミュータブル（immutable）の特性を持ちます。 JavaScriptでは、文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種として扱われます。

一方、プリミティブ型ではないものをオブジェクト（複合型）と呼び、 オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合です。 オブジェクトは、一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性を持ちます。 オブジェクトは、値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言います。

```
console.log(typeof true);// => "boolean"
console.log(typeof 42); // => "number"
console.log(typeof 9007199254740992n); // => "bigint"
console.log(typeof "JavaScript"); // => "string"
console.log(typeof Symbol("シンボル"));// => "symbol"
console.log(typeof undefined); // => "undefined"
console.log(typeof null); // => "object"
console.log(typeof ["配列"]); // => "object"
console.log(typeof { "key": "value" }); // => "object"
console.log(typeof function() {}); // => "function"
```

プリミティブ型の値は、それぞれ`typeof`演算子の評価結果として、その値のデータ型を返します。 一方で、オブジェクトに分類される値は`"object"`となります。

配列(`[]`)とオブジェクト(`{}`)は、どちらも`"object"`という判定結果になります。 そのため、`typeof`演算子ではオブジェクトの詳細な種類を正しく判定することはできません。 ただし、関数はオブジェクトの中でも特別扱いされているため、`typeof`演算子の評価結果は`"function"`となります。 また、`typeof null`が`"object"`となるのは、歴史的経緯のある仕様のバグ<sup><a href="https://jsprimer.net/basic/variables//#fn_1" id="reffn_1">1</a></sup>です。

このことからもわかるように`typeof`演算子は、プリミティブ型またはオブジェクトかを判別するものです。 `typeof`演算子では、オブジェクトの詳細な種類を判定できない。

### リテラル
プリミティブ型の値や一部のオブジェクトは、**リテラル**を使うことで簡単に定義できるようになっています。

リテラルとはプログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたものです。 たとえば、`"`と`"`で囲んだ範囲が文字列リテラルで、これは文字列型のデータを表現しています。

次の5つのプリミティブ型は、それぞれリテラル表現を持っています。

-   真偽値
-   数値
-   BigInt
-   文字列
-   null

また、オブジェクトの中でもよく利用されるものに関してはリテラル表現が用意されています。

-   オブジェクト
-   配列
-   正規表現


## 感想（一日の感想、雑談）
- javascriptの課題をあまり進めることができなかった。
- 土日は時間確保が難しいため、スキマ時間で少しでも成長に繋がる学びを得たい。


## 明日の目標（TODO目標/できるようになりたいこと）
- スキマ時間に「JavaScript Primer」を読む。
<!-- - JavaScript
  - QUEST 8～10を終わらせる
- HTML/CSS
  - Webサイト部分模写を1hする。(目標:Webサイトを構造を把握する視点を養う。毎日新しい学びを1つ獲ること。) -->

### 残タスク
- HTML/CSS スタイルガイドに則って書ける
- 模写するページの選定（オリジナルプロダクトの参考となるWebイト）

<!-- - 「HTML&CSSとWebデザイン」本 -->
<!-- - 「HTML解体新書」本 -->

<!-- - 要件定義 -->
<!-- - 機能要件
- 非機能要件 -->

<!-- - c.移動中などスキマ時間に要件定義事例を読む (釜谷さんが紹介してくださっていた資料) -->
  <!-- - 現時点で難易度が見えていないため、まずは挑戦してみる -->


<!-- #### 残タスク / できるようになりたいこと
- 包括的なWeb技術の基本理解->「プロになるためのWeb技術入門」本
- オリジナルプロダクト制作のテーマ探索
- SRE業務の理解
- 質問する技術の習得 -->

<!-- ##### Ruby
- RuboCopの使用
- 「Rubyの公式リファレンスが読めるようになる本」 -->

<!-- ##### Linux
- 「実践入門」
- 「シェルスクリプト160本ノック」
- 「入門モダンLinux」
- 「Linuxのしくみ」
- 「スーパーユーザーなら知っておくべきLinuxシステムの仕組み」
- 「入門Rust」?
- 仮想化、コンテナ(TenForward)、コンテナオーケストレーション -->
<!-- 
##### SQL
- sqlbplt
- 「達人に学ぶSQL」 -->