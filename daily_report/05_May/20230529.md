# 日報
- 5/29（月）

## 本日の目標（TODO目標/できるようになりたいこと）
- JavaScript
  - a.QUEST 8～10を終わらせる
- HTML/CSS
  - b.Webサイト部分模写を1hする。(目標:Webサイトを構造を把握する視点を養う。毎日新しい学びを1つ獲ること。)

## 学習時間（Hour）
- 【本日】5h
- 【今週(目標:35h)】月:5h 火:h 水:h 木:h 金:h 土:h 日:h
- 【前週まで】29h/32h/36h/

## 目標振り返り（TODO進捗/できるようになりたいこと振り返り）
- a.未達(8のみ完了。) b.未達

## 詰まっていること（実現したいこと/現状/行ったこと/仮説）
- なし

<!-- ```
・実現したいこと
・現状
・行ったこと
・仮説
``` -->

## 学んだこと（新しい気付き、学び）
### \[ES2015\] デフォルト引数

デフォルト引数（デフォルトパラメータ）は、仮引数に対応する引数が渡されていない場合に、デフォルトで代入される値を指定できます。

※引数を渡さずに呼び出すと、仮引数には`undefined`が入ります。

```
function 関数名(仮引数1 = デフォルト値1, 仮引数2 = デフォルト値2) {

}
```

## 可変長引数

関数において引数の数が固定ではなく、任意の個数の引数を受け取りたい場合があります。 

可変長引数を実現するためには、Rest parametersか関数の中でのみ参照できる`arguments`という特殊な変数を利用します。

### \[ES2015\] Rest parameters

Rest parametersは、仮引数名の前に`...`をつけた仮引数のことで、残余引数とも呼ばれます。 Rest parametersには、関数に渡された値が配列として代入されます。

次のコードでは、`fn`関数に`...args`というRest parametersが定義されています。 この`fn`関数を呼び出したときの引数の値が、`args`という変数に配列として代入されます。

```
function fn(...args) {
    // argsは、渡された引数が入った配列
    console.log(args); // => ["a", "b", "c"]
}
fn("a", "b", "c");
```

Rest parametersは、通常の仮引数と組み合わせても定義できます。 ほかの仮引数と組み合わせる際には、必ずRest parametersを末尾の仮引数として定義する必要があります。

次のコードでは、1番目の引数は`arg1`に代入され、残りの引数が`restArgs`に配列として代入されます。

```
function fn(arg1, ...restArgs) {
    console.log(arg1); // => "a"
    console.log(restArgs); // => ["b", "c"]
}
fn("a", "b", "c");
```

### Spread構文
一方で、Spread構文は、配列の前に`...`をつけた構文のことで、関数には配列の値を展開したものが引数として渡されます。 次のコードでは、`array`の配列を展開して`fn`関数の引数として渡しています。

```
function fn(x, y, z) {
    console.log(x); // => 1
    console.log(y); // => 2
    console.log(z); // => 3
}
const array = [1, 2, 3];
// Spread構文で配列を引数に展開して関数を呼び出す
fn(...array);
// 次のように書いたのと同じ意味
fn(array[0], array[1], array[2]);
```


### `arguments` ※非推奨

可変長引数を扱う方法として、`arguments`という関数の中でのみ参照できる特殊な変数があります。 `arguments`は関数に渡された引数の値がすべて入った**Array-like**なオブジェクトです。 **Array-like**なオブジェクトは、配列のようにインデックスで要素へアクセスできます。 しかし、`Array`ではないため、実際の配列とは異なり`Array`のメソッドは利用できないという特殊なオブジェクトです。

次のコードでは、`fn`関数に仮引数が定義されていません。 しかし、関数の内部では`arguments`という変数で、実際に渡された引数を配列のように参照できます。

```
function fn() {
    // `arguments`はインデックスを指定して各要素にアクセスできる
    console.log(arguments[0]); // => "a"
    console.log(arguments[1]); // => "b"
    console.log(arguments[2]); // => "c"
}
fn("a", "b", "c");
```
Rest parametersが利用できる環境では、`arguments`変数を使うべき理由はありません。 `arguments`変数には次のような問題があります。

-   Arrow Functionでは利用できない（Arrow Functionについては後述）
-   Array-likeオブジェクトであるため、Arrayのメソッドを利用できない
-   関数が可変長引数を受けつけるのかを仮引数だけを見て判断できない

このように、可変長引数が必要な場合は`arguments`変数よりも、Rest parametersでの実装を推奨します。


## \[ES2015\] 関数の引数と分割代入

関数の引数においても分割代入（Destructuring assignment）が利用できます。 分割代入はオブジェクトや配列からプロパティを取り出し、変数として定義し直す構文です。

次のコードでは、関数の引数として`user`オブジェクトを渡し、`id`プロパティをコンソールへ出力しています。

```
function printUserId(user) {
    console.log(user.id); // => 42
}
const user = {
    id: 42
};
printUserId(user);
```

代入演算子（`=`）におけるオブジェクトの分割代入では、左辺に定義したい変数を定義し、右辺のオブジェクトから対応するプロパティを代入していました。 関数の仮引数が左辺で、関数に渡す引数を右辺と考えるとほぼ同じ構文であることがわかります。

```
const user = {
    id: 42
};
// オブジェクトの分割代入
const { id } = user;
console.log(id); // => 42
// 関数の引数の分割代入
function printUserId({ id }) {
    console.log(id); // => 42
}
printUserId(user);
```

関数の引数における分割代入は、オブジェクトだけではなく配列についても利用できます。 次のコードでは、引数に渡された配列の1番目の要素が`first`に、2番目の要素が`second`に代入されます。

```
function print([first, second]) {
    console.log(first); // => 1
    console.log(second); // => 2
}
const array = [1, 2];
print(array);
```


### 関数はオブジェクト

JavaScriptでは、関数は関数オブジェクトとも呼ばれ、オブジェクトの一種です。 関数はただのオブジェクトとは異なり、関数名に`()`をつけることで、関数としてまとめた処理を呼び出すことができます。

一方で、`()`をつけて呼び出されなければ、関数をオブジェクトとして参照できます。 また、関数はほかの値と同じように変数へ代入したり、関数の引数として渡すことが可能です。

このように関数が値として扱えることを、**ファーストクラスファンクション**（第一級関数）と呼びます。

関数式は、以下2つの方法がある。
- functionキーワードを使った方法
- [ES2015] Arrow Function

> Arrow Functionで問題ない場合はArrow Functionで書き、そうでない場合は`function`キーワードを使うことを推奨。

#### functionキーワードを使った方法

```js
// 関数式は変数名で参照できるため、"関数名"を省略できる
const 変数名 = function() {
};
// 関数宣言では"関数名"は省略できない
function 関数名() {
}
```

このように関数式では、名前を持たない関数を変数に代入できます。 このような名前を持たない関数を**匿名関数**（または無名関数）と呼びます。

もちろん関数式でも関数に名前をつけることができます。 しかし、この関数の名前は関数の外からは呼ぶことができません。 一方、関数の中からは呼ぶことができるため、再帰的に関数を呼び出す際などに利用されます。

```
// factorialは関数の外から呼び出せる名前
// innerFactは関数の外から呼び出せない名前
const factorial = function innerFact(n) {
    if (n === 0) {
        return 1;
    }
    // innerFactを再帰的に呼び出している
    return n * innerFact(n - 1);
};
console.log(factorial(3)); // => 6
```


#### [ES2015] Arrow Function
関数式には`function`キーワードを使った方法以外に、Arrow Functionと呼ばれる書き方があります。 名前のとおり矢印のような`=>`（イコールと大なり記号）を使い、匿名関数を定義する構文です。 次のように、`function`キーワードを使った関数式とよく似た書き方をします。

```
// Arrow Functionを使った関数定義
const 変数名 = () => {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返す値;
};
```

Arrow Functionには書き方にいくつかのパターンがありますが、`function`キーワードに比べて短く書けるようになっています。 また、Arrow Functionには省略記法があり、次の場合にはさらに短く書けます。

-   関数の仮引数が1つのときは`()`を省略できる
-   関数の処理が1つの式である場合に、ブロックと`return`文を省略できる
    -   その式の評価結果を`return`の返り値とする

```
// 仮引数の数と定義
const fnA = () => { /* 仮引数がないとき */ };
const fnB = (x) => { /* 仮引数が1つのみのとき */ };
const fnC = x => { /* 仮引数が1つのみのときは()を省略可能 */ };
const fnD = (x, y) => { /* 仮引数が複数のとき */ };
// 値の返し方
// 次の２つの定義は同じ意味となる
const mulA = x => { return x * x; }; // ブロックの中でreturn
const mulB = x => x * x;            // 1行のみの場合はreturnとブロックを省略できる
```

Arrow Functionについては次のような特徴があります。

-   名前をつけることができない（常に匿名関数）
-   `this`が静的に決定できる
-   `function`キーワードに比べて短く書くことができる
-   `new`できない（コンストラクタ関数ではない）
-   `arguments`変数を参照できない

たとえば`function`キーワードの関数式では、値を返すコールバック関数を次のように書きます。 配列の`map`メソッドは、配列の要素を順番にコールバック関数へ渡し、そのコールバック関数が返した値を新しい配列にして返します。

```
const array = [1, 2, 3];
// 1,2,3と順番に値が渡されコールバック関数（匿名関数）が処理する
const doubleArray = array.map(function(value) {
    return value * 2; // 返した値をまとめた配列ができる
});
console.log(doubleArray); // => [2, 4, 6]
```

Arrow Functionでは処理が1つの式だけである場合に、`return`文を省略し暗黙的にその式の評価結果を`return`の返り値とします。

次のコードは、先ほどの`function`キーワードで書いたコールバック関数と同じ結果になります。

```
const array = [1, 2, 3];
// 仮引数が1つなので`()`を省略できる
// 関数の処理が1つの式なので`return`文を省略できる
const doubleArray = array.map(value => value * 2);
console.log(doubleArray); // => [2, 4, 6]
```

Arrow Functionは`function`キーワードの関数式に比べて、できることとできないことがはっきりしています。 たとえば、`function`キーワードでは非推奨としていた`arguments`変数を参照できますが、Arrow Functionでは参照できなくなっています。 Arrow Functionでは、人による解釈や実装の違いが生まれにくくなります。

また、`function`キーワードとArrow Functionの大きな違いとして、`this`という特殊なキーワードに関する挙動の違いがあります。 この`this`の問題の多くを解決できるという利点があります。

そのため、Arrow Functionで問題ない場合はArrow Functionで書き、そうでない場合は`function`キーワードを使うことを推奨します。

### 同じ名前の関数宣言は上書きされる
関数定義の上書きはfunctionキーワードでの関数宣言とvarキーワードを使った関数式のみで発生します。 一方で、constやletでは同じ変数名の定義はエラーとなる。

関数の上書きを避けたい場合は、constと関数式を使って関数を定義することで、意図しない上書きが発生しにくくなります。


<!-- ### 非同期処理とは -->


<!-- ### DOMとは -->

## 感想（一日の感想、雑談）
- この数日、調子を崩してしまったので明日は着実にすすめていきたい。


## 明日の目標（TODO目標/できるようになりたいこと）
- JavaScript
  - QUEST 9～10を終わらせる
- HTML/CSS
  - Webサイト部分模写を1hする。(目標:Webサイトを構造を把握する視点を養う。毎日新しい学びを1つ獲ること。)
- 提出課題(模写)サイト選び

### 残タスク
- HTML/CSS スタイルガイドに則って書ける
- 模写するページの選定（オリジナルプロダクトの参考となるWebイト）

<!-- - 「HTML&CSSとWebデザイン」本 -->
<!-- - 「HTML解体新書」本 -->

<!-- - 要件定義 -->
<!-- - 機能要件
- 非機能要件 -->

<!-- - c.移動中などスキマ時間に要件定義事例を読む (釜谷さんが紹介してくださっていた資料) -->
  <!-- - 現時点で難易度が見えていないため、まずは挑戦してみる -->


<!-- #### 残タスク / できるようになりたいこと
- 包括的なWeb技術の基本理解->「プロになるためのWeb技術入門」本
- オリジナルプロダクト制作のテーマ探索
- SRE業務の理解
- 質問する技術の習得 -->

<!-- ##### Ruby
- RuboCopの使用
- 「Rubyの公式リファレンスが読めるようになる本」 -->

<!-- ##### Linux
- 「実践入門」
- 「シェルスクリプト160本ノック」
- 「入門モダンLinux」
- 「Linuxのしくみ」
- 「スーパーユーザーなら知っておくべきLinuxシステムの仕組み」
- 「入門Rust」?
- 仮想化、コンテナ(TenForward)、コンテナオーケストレーション -->
<!-- 
##### SQL
- sqlbplt
- 「達人に学ぶSQL」 -->