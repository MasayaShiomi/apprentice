20230415

## 余談：VScodeでRubyを気軽に実行する環境を作る (Windows10/11)
VScode のインストールは[こちら]()

VScodeのメニューから
表示>ターミナル でターミナルを立ち上げます。

ターミナルから、`ruby -v` と打ちます。

インストールされてない場合は

Downloads  
[https://rubyinstaller.org/downloads/](https://rubyinstaller.org/downloads/)
から `WITH DEVKIT` 版をダウンロードしてインストールします。

※DEVKITなしでもRubyは動作しますが、ライブラリを利用する場合に必要となる場合がありますので、DEVKITありをインストールした方が無難です。

※ インストーラーを進めるとコマンドプロンプトが起動して2回程質問されますが、`Enter`キーを叩けばOKです。

※Rubyのバージョンが古く固定されているので、複数のバージョンをインストールしたり、切り替えることのできる[rbenv](https://github.com/rbenv/rbenv)や[rvm](https://rvm.io/)をインストールして利用します。  
ebenvやrvmの使い方については、[●●●]()↩


インストール終了後、  
再び `ruby -v` と打ち、インストールされたかどうかを確認します。

バージョンが確認ができたら、

さっそくRubyのコードを実行してみましょう。
- 作業用フォルダを作ります。
- フォルダ内にファイル `hello.rb` を作成し、コードを記述します。
```Ruby
puts "Hello, World!"
```

- 保存したら、コマンドプロンプトで作成したフォルダまで移動します。  
- `ruby ファイル名` で実行することができます。
```Ruby
フォルダ名\ ruby hello.rb
```
↓出力結果
```Ruby
Hello, World!
```

### 参考
[Qiita: VSCodeでRubyを気軽に実行する環境を作る。](https://qiita.com/masakinihirota/items/ec90086bab86f369fa15)

[Rubyの開発環境を用意しよう！（Windows用）](https://prog-8.com/docs/ruby-env-win)

*****

## オブジェクト指向とは何か
わからん。

ちまちまと言葉で説明を聞くより、まずは手を動かしたいという猛者はこちら->[オブジェクト指向 レベル別練習問題30]()

### 1. オブジェクト指向の目的
#### 初学者の自分へ ver
```
```

#### 一般的(?)な説明

オブジェクト指向は、プログラミングの方法論の1つであり、現実世界の物事をコンピュータ上で表現するために使用されます。オブジェクト指向の目的は、複雑なシステムを構築することができる柔軟で保守性が高いソフトウェアを開発することです。この目的を達成するために、オブジェクト指向では、データと手続きを1つの単位で扱う「オブジェクト」と呼ばれる構造体を使用します。オブジェクトは、自己完結型の機能を持ち、他のオブジェクトと相互作用することができます。


### 2. カプセル化
#### 初学者の自分へ ver
```
```

#### 一般的(?)な説明

オブジェクト指向におけるカプセル化とは、オブジェクト内部のデータと手続きを隠蔽し、外部からのアクセスを制限することを指します。これにより、オブジェクトの内部実装の詳細が隠蔽され、他のオブジェクトやコードが意図せずデータを破壊することがなくなります。また、オブジェクトの実装を変更しても、他のコードに影響を与えることなく変更できるため、保守性が向上します。


### 3. 継承
#### 初学者の自分へ ver


#### 一般的(?)な説明

オブジェクト指向における継承とは、既存のクラスを基にして新しいクラスを作成することを指します。新しいクラスは、既存のクラスの機能を継承し、新しい機能を追加することができます。これにより、コードの再利用性が向上し、同じような機能を持つクラスを複数作成する必要がなくなります。また、継承によって、プログラムの階層構造を作成することができます。


### 4. ポリモーフィズム
#### 初学者の自分へ ver



#### 一般的(?)な説明

オブジェクト指向におけるポリモーフィズムとは、同じインターフェースを持つ複数のオブジェクトが、それぞれ異なる動作をすることを指します。つまり、同じメソッド名を持つ複数のオブジェクトがあっても、それぞれのオブジェクトは異なる実装を持つことができます。この機能によって、コードの柔軟性が向上し、オブジェクトの振る舞いをより柔軟に変更することができます。

例えば、動物クラスには「鳴く」というメソッドがあるとします。継承を使って、犬クラスと猫クラスを作成することができます。犬クラスと猫クラスは、動物クラスから「鳴く」というメソッドを継承しますが、犬は「ワン」と鳴き、猫は「ニャー」と鳴くように実装されます。これにより、同じ動物クラスのインスタンスでも、それぞれ異なる鳴き声を出すことができます。


### 5. 単一責任の原則
#### 初学者の自分へ ver



#### 一般的(?)な説明

オブジェクト指向の重要な設計原則の1つに、「単一責任の原則」があります。この原則は、クラスは1つの責務（役割）のみを持つべきであり、複数の責務を持つことがないように設計すべきであるというものです。これにより、クラスの役割が明確になり、コードの保守性が向上します。

例えば、顧客クラスには、顧客の情報を管理する責務があるとします。しかし、顧客クラスに請求書の発行も含めると、責務が2つになってしまいます。この場合、請求書発行のための別のクラスを作成することで、顧客クラスの責務を単一にすることができます。


### 参考
[ゆるコンピュータ]()


## クラスを作ってみる
クラスは設計図のこと
クラスから インスタンス (実態) を作成する
#### 記入例
```Ruby
# human.rb
# クラス名は大文字にする
class Human
	def hello
		puts "Hello"
	end
end

# クラス (設計図)から インスタンス (実態) を作成する
human = Human.new
# 実行する
human.hello
```
#### 表示結果
```Ruby
Hello
```
## initialize メソッド

#### 記入例
```Ruby
# クラス名は大文字にする
class Human
	# initialize メソッド を定義
	def initialize(name)
		# @nameという インスタンス変数 はHumanクラスのインスタンス内であればどこでも使える
		@name = name
	end

	def hello
		puts "Hello! I am #{@name}"
	end
end

# クラス (設計図)から インスタンス (実態) を作成して変数に入れる
gary = Human.new('Gary')
# 変数.関数名 で実行する
gary.hello

ryan = Human.new('Ryan')
ryan.hello

ross = Human.new('Ross')
ross.hello
```
#### 表示結果
```Ruby
Hello! I am Gary
Hello! I am Ryan
Hello! I am Ross
```

## アクセサ (accesor) メソッド①
インスタンス変数の値を読み書きするメソッドのこと

#### インスタンス変数`@name`を、クラスの外部から参照したい

##### 記入例

```Ruby
class Human
	# initialize メソッド を定義
	def initialize(name)
		@name = name
	end

	# @name をクラス外部から参照するためのメソッドを定義する
	def name
		@name
	end
end

# クラス (設計図)から インスタンス (実態) を作成して変数に入れる
gary = Human.new('Gary')
# インスタンス変数 @name をクラス外部から呼び出せる
puts gary.name
```

##### 表示結果
```Ruby
Gary
```

#### インスタンス変数`@name`を、クラスの外部から書き換えたい
`@name`書き換え用のメソッドを用意する
->`インスタンスメソッド` と呼ばれる

他のプログラミング言語ではgetメソッド、setメソッドに該当するものらしい

##### 記入例
```Ruby
class Human
	# initialize メソッド を定義
	def initialize(name)
		@name = name
	end

	# @name をクラス外部から参照するためのメソッドを定義する
	def name
		@name
	end

	# @name 書き換え用のメソッドを用意する
	def name=(value)
		@name = value
	end
end

# クラス (設計図)から インスタンス (実態) を作成して変数に入れる
gary = Human.new('Gary')
puts gary.name

# @name を書き換える
gary.name = "Dora"
puts gary.name
```

#### 表示結果
```Ruby
Gary
Dora
```

## アクセサ (accesor) メソッド②
attr_accessorメソッド をつかれば、
インスタンスメソッドを開発者が書かなくて良くなる

※attr = attribute 属性。他のプログラミング言語では「プロパティ」と呼ばれているものらしい

#### インスタンス変数`@name`を、クラスの外部から書き換えたい (attr_accessorメソッド版)

##### 記入例

```Ruby
class Human
	# インスタンス変数 @name を読み書きするメソッドを定義する
	# これによってインスタンスメソッドの定義が不要になる
	attr_accessor :name
	# initialize メソッド を定義
	def initialize(name)
		@name = name
	end

end

# クラス (設計図)から インスタンス (実態) を作成して変数に入れる
gary = Human.new('Gary')
puts gary.name

# @name を書き換える
gary.name = "Dora"
puts gary.name
```

##### 表示結果
```Ruby
Gary
Dora
```
先ほどと同様の結果が得られた

尚、インスタンス変数の書き込みは `attr_writer` 、読み取りのみは `attr_reader` を使う

## クラス変数
クラス自体に値を保持することができる変数 @@count

#### 例題
Humanクラスのインスタンスが作成された回数をカウントして出力する

##### 記入例

```Ruby
class Human
	# クラス変数を定義
	@@count = 0
	def initialize(name)
		@name = name
		# インスタンスが呼び出された回数を @@count に代入してカウントする
		@@count += 1
	end

	def hello
		puts "Hello I am #{@name}."
		puts "インスタンス呼び出し回数: #{@@count} "
	end
end

taro = Human.new("Taro")
taro.hello

ryan = Human.new('Ryan')
ryan.hello

ross = Human.new('Ross')
ross.hello
```

##### 表示結果
```Ruby
Hello I am Taro.
インスタンス呼び出し回数: 1
Hello I am Ryan.
インスタンス呼び出し回数: 2
Hello I am Ross.
インスタンス呼び出し回数: 3
```

## クラスメソッド
クラスから直接呼ぶことができるメソッド

#### 例題
クラスメソッド `info` を定義

クラスメソッド `info` を実行すると、インスタンスの生成回数 `@@count` を出力する

##### 記入例

```Ruby
class Human
	# クラス変数を定義
	@@count = 0
	def initialize(name)
		@name = name
		# インスタンスが呼び出された回数を @@count に代入してカウントする
		@@count += 1
	end

	def hello
		puts "Hello I am #{@name}."
		puts "インスタンス呼び出し回数: #{@@count} "
	end

	# クラスメソッドを定義する
	def self.info
		puts "インスタンス呼び出し回数: #{@@count} "
	end

end

# インスタンスを作成せずに直接クラスメソッドを呼び出している
Human.info

taro = Human.new("Taro")
taro.hello

ryan = Human.new('Ryan')
ryan.hello

ross = Human.new('Ross')
ross.hello

Human.info
```


##### 表示結果
```Ruby
インスタンス呼び出し回数: 0
Hello I am Taro.
インスタンス呼び出し回数: 1
Hello I am Ryan.
インスタンス呼び出し回数: 2
Hello I am Ross.
インスタンス呼び出し回数: 3
インスタンス呼び出し回数: 3
```

## クラスと定数 (const)


#### 

##### 記入例

```Ruby
class Human
	# 定数を定義
	AREA = "NewYork"

	# 変数を定義
	@@count = 0
	def initialize(name)
		@name = name
		# インスタンスが呼び出された回数を @@count に代入してカウントする
		@@count += 1
	end

	def hello
		puts "Hello I am #{@name}."
	end

	# クラスメソッドを定義する
	def self.info
		# 定数をクラスメソッドから呼び出す
		puts "インスタンス呼び出し回数: #{@@count}. AREA: #{AREA}"
	end

end

# インスタンスを作成せずに直接クラスメソッドを呼び出している
Human.info

taro = Human.new("Taro")
taro.hello

ryan = Human.new('Ryan')
ryan.hello

ross = Human.new('Ross')
ross.hello

Human.info

# 定数を外部から直接呼び出す
puts Human::AREA
```


##### 表示結果
```Ruby
インスタンス呼び出し回数: 0. AREA: NewYork
Hello I am Taro.
Hello I am Ryan.
Hello I am Ross.
インスタンス呼び出し回数: 3. AREA: NewYork
NewYork
```

## クラスの継承
親クラス (スーパークラス) の機能を引き継いで、子クラス (サブクラス) を作成することができる

コードの再利用性や拡張性を高める仕組み

#### 例
- 【親】自動車クラス (タイヤ、エンジン、ブレーキ)
  - 【子】戦車クラス ( + 大砲 )
  - 【子】乗用車クラス ( + 後部座席 )
  - 【子】トラッククラス ( + 荷台 )

#### 例題の進め方
1. `User` クラスを作成する
2. 自己紹介するメソッド `hello` を追加する
3. `User` クラスを継承した、`AdminUser` クラスを作成する
4. 管理者として自己紹介するメソッド `admin_hello` を追加する

##### 記入例①

```Ruby
class User
	def initialize(name)
		@name = name
	end

	def hello
		puts "Hello! I am #{@name}."
	end
end

# < 継承したい親クラス を書く
class AdminUser < User

end

user = User.new("Hirasawa")
user.hello

# AdminUserクラスが空だったとしても継承しているためUserクラスのhelloメソッドが呼び出せる
user = AdminUser.new("Akiyama")
user.hello
```

##### 表示結果
```Ruby
Hello! I am Hirasawa.
Hello! I am Akiyama.
```


## 

#### 

##### 記入例②

```Ruby
class User
	def initialize(name)
		@name = name
	end

	def hello
		puts "Hello! I am #{@name}."
	end
end

# < 継承したい親クラス を書く
class AdminUser < User
	# 子クラスにメソッドを定義する
	def admin_hello
		puts "Hello! I am #{@name} from AdminUser."
	end
end

hirasawa = User.new("Hirasawa")
hirasawa.hello
# hirasawa.adamin_hello		# 親クラスから子クラスは呼び出せない

akiyama = AdminUser.new("Akiyama")
akiyama.hello
# 子クラスに定義されている admin_user メソッドを呼び出す
akiyama.admin_hello

```


##### 表示結果
```Ruby
Hello! I am Hirasawa.
Hello! I am Akiyama.
Hello! I am Akiyama from AdminUser.
```


## メソッドの"オーバーライド"
親クラスが持っているメソッドを子クラスで編集して使うことができる

#### 

##### 記入例

```Ruby
class User
	def initialize(name)
		@name = name
	end

	def hello
		puts "Hello! I am #{@name}."
	end
end

# < 継承したい親クラス を書く
class AdminUser < User
	# 子クラスにメソッドを定義する
	def admin_hello
		puts "Hello! I am #{@name} from AdminUser."
	end

	# 親クラスのhelloメソッドを子クラスへオーバーライドする
	def hello
		puts "Adminです!"
	end
end


akiyama = AdminUser.new("Akiyama")
akiyama.hello
# 子クラスに定義されている admin_user メソッドを呼び出す
akiyama.admin_hello

```


##### 表示結果
```Ruby
Adminです!		#=> 子クラスにオーバーライドされた helloメソッドが呼び出される
Hello! I am Akiyama from AdminUser.
```




## 【余談】Integerの継承関係
【親】  
BasicPbject  
↑  
Object  
↑  
Numeric  
↑  
Integer  
【子】

#### irb で確認してみる

```Ruby
irb(main):001:0> Integer.superclass
=> Numeric
irb(main):002:0> Numeric.superclass
=> Object
irb(main):003:0> Object.superclass
=> BasicObject
irb(main):004:0> BasicObject.superclass
=> nil
```

## モジュール
クラスのようにメソッドや定数をまとめられる

関連するメソッドや定数などをまとめてグループ化したいだけのときに、手軽に使えて便利

### クラスとの違い
インスタンスを作ることができない

継承ができない

### モジュールの定義
```Ruby
modele モジュール名
	# モジュールの定義 (メソッドや定数など)
end
```

### 例
自動者の運転者に関するモジュールの作成
- Run と出力するメソッド
- Stop と出力するメソッド

##### 記入例

```Ruby
# モジュールを定義する
module Driver
	# インスタンスメソッドが作れないため selfを付ける
	def self.run
		puts "Run"
	end
	
	def self.stop
		puts "Stop"
	end
end

# モジュールのメソッドを呼び出す
Driver.stop
Driver.run
```

##### 表示結果
```Ruby
Stop
Run
```


## 例外と例外処理
#### 例外 (Exception) 
プログラムの実行中に発生した「例外」的な問題のこと

#### 例外処理
例外、つまり予期しないエラーが発生した時に、それをキャッチして、ユーザーにメッセージを表示するなど、何らかの処理を行うこと

### 例題
1. 数値10を、ユーザーが入力した数値で割り、その結果を出力するプログラムを作成
2. 数値が0で割られた時に、その例外をキャッチして
3. エラーメッセージを出力する

##### 記入例

```Ruby
# ターミナルから入力させる
puts "整数を入力してエンターを押してください:"
i = gets.to_i

begin
	puts "10 / #{i} = #{10 / i} です"
rescue => ex		# exは変数で任意の名前でよい。例外オブジェクトが入っていて、エラーに関する情報が取得できる
	puts "Error!"
	puts ex.message		# エラー内容
	puts ex.class			# 例外オブジェクトのクラス種類
ensure
	puts "end"		# 例外が発生しても、しなくても最後に実行したい処理
end
```

##### 表示結果
```Ruby
# 例外なし
整数を入力してエンターを押してください:
2
10 / 2 = 5 です
end

整数を入力してエンターを押してください:
-5
10 / -5 = -2 です
end

# 0 を入力すると例外処理となった
整数を入力してエンターを押してください:
0
Error!
divided by 0
ZeroDivisionError
end
```

## Rubyのコーディングルールについて
存在しない? 

「The Ruby Style Guide」が有名。  
[オリジナル: https://github.com/rubocop/ruby-style-guide](https://github.com/rubocop/ruby-style-guide)  
[日本語訳: https://github.com/fortissimo1997/ruby-style-guide/blob/japanese/README.ja.md](https://github.com/fortissimo1997/ruby-style-guide/blob/japanese/README.ja.md)

Rubyのソースコード解析ツールRuboCopの作者と同じ  
->「The Ruby Style Guide」のルールに則っているかをチェックしてくれるツールです！



## メソッドの公開範囲
メソッドにアクセスできる条件を指定できるもの
- public  
誰からも見える  
何も指定しなければ `public` になる

- protected  
(※初心者ではあまり使われないので説明省略)  
Java経験者は用語の意味合いが違うので要注意

- private  
自分からしか見えない  
外部から呼んでほしくないメソッドを守る  
オブジェクト内部のデータ・振る舞いを外から見えなくする  
->**カプセル化**

###

##### 例①

```Ruby
class User
	def initialize(name)
		@name = name
	end

	def hello
		puts "Hello! I am #{@name}."
	end

	# private 以下はprivateメソッドとなる。インデント推奨。
	private
		def hello2
			puts "Hello! I am #{@name}."
		end
end

hirasawa = User.new("Hirasawa")
hirasawa.hello

akiyama = User.new("Akiyama")
akiyama.hello2
```

##### 表示結果
```Ruby
Hello! I am Hirasawa.
./access.rb:21:in `<main>': private method `hello2' called for #<User:0x00000236905bd178 @name="Akiyama"> (NoMethodError)

akiyama.hello2
       ^^^^^^^
Did you mean?  hello
```
privateメソッドの hello2メソッドはエラーになる


## 
###

##### 例② privateメソッドを外部から呼ぶ場合

```Ruby
class User
	def initialize(name)
		@name = name
	end

	# クラス内のprivateメソッドを内部で呼んでいる
	def say
		hello
	end

	private
		def hello
			puts "Hello! I am #{@name}."
		end
end

hirasawa = User.new("Hirasawa")
hirasawa.say
```

##### 表示結果
```Ruby


```




## 「クラスメソッド」と「インスタンスメソッド」の違い
- 定義の仕方
クラスメソッドは、クラス自身に定義されたメソッドであり、メソッド名の前に self. を付けることで定義されます。一方、インスタンスメソッドは、インスタンスに対して呼び出されるメソッドであり、クラス内のメソッド定義の中で self. を付けずに定義されます。

- 呼び出し方
クラスメソッドは、クラス名に続けてメソッド名を書くことで呼び出されます。例えば、MyClass.my_class_method のように呼び出します。一方、インスタンスメソッドは、インスタンスに対して . を使って呼び出します。例えば、my_instance.my_instance_method のように呼び出します。

- インスタンス変数の扱い方
インスタンスメソッドは、インスタンス内のインスタンス変数にアクセスすることができますが、クラスメソッドはクラス自身が持つクラス変数にしかアクセスできません。
###

##### 記入例

```Ruby
class MyClass
  def self.my_class_method
    @class_var = "This is a class variable"
  end

  def initialize
    @instance_var = "This is an instance variable"
  end

  def my_instance_method
    puts @instance_var
  end
end

MyClass.my_class_method # クラスメソッドの呼び出し
my_instance = MyClass.new # インスタンスの生成
my_instance.my_instance_method # インスタンスメソッドの呼び出し


```

##### 表示結果
```Ruby


```




## 
###

##### 記入例

```Ruby


```

##### 表示結果
```Ruby


```




## 
###

##### 記入例

```Ruby


```

##### 表示結果
```Ruby


```



## 
###

##### 記入例

```Ruby


```

##### 表示結果
```Ruby


```



