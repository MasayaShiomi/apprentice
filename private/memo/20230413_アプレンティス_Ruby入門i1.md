20230413
## メソッド
複数の処理を1つにまとめて、扱いやすくしたもの

クラス内に定義する

≒クラス内に定義する関数


<!-- - [ ] aaaa		# チェックボックス 半角スペースの扱いにご注意 -->

### 構文
```Ruby
def メソッド名(引数1, 引数2, ・・・)
	# 実行したい処理
end
```
defはdefine(定義する)の略。

### 例①
引数のないメソッド

```Ruby
def hello_woeld
	puts 'Hello, World!'
end

hello_world
```

 任意のファイル名.rbで保存して、ruby ファイル名.rbを実行するとプログラムを実行できます。ちなみに、Rubyを実行する環境構築の方法はこちらが参考になります。

 #### 戻り値について
Rubyでは、returnを記入しないのが慣習のようです。

### 例②
引数のあるメソッド

```Ruby
def add(x, y)
	x + y
end

puts add(3, 5)
```

### 例③
演習：FizzBuzzメソッドの作成

#### FizzBuzzとは
- 3で割り切れる数値を引数に渡すと、'Fizz'を返す
- 5で割り切れる数値を引数に渡すと、'Buzz'を返す
- 15で割り切れる数値を引数に渡すと、'FizzBuzz'を返す
- それ以外の数値は、その数値を文字列に変えて返す

#### 補足
- メソッド名はfizz_buzzとする
- 引数名はnとする
- 引数nは1以上の整数が入る
- puts fizz_buzz(1)のようにしてメソッドを呼び出し、動作が正しいか確認
- 数字は1~15の範囲で確認

#### 記入例
```Ruby
def fizz_buzz(n)
  if n % 15 == 0
    'FizzBuzz'
  elsif n % 3 == 0
    'Fizz'
  elsif n % 5 == 0
    'Buzz'
  else
    n.to_s
  end
end

# 繰り返し処理を使って、1～15まで順番にnに代入してメソッドを実行しています
1.upto(15) do |i|
  puts fizz_buzz(i)
end
```

#### 表示結果
```Ruby
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
```

## 出力 puts, print, p, pp
### puts
引数として渡されたオブジェクトの文字列表現を改行付きで出力します。つまり、引数が文字列であればそのまま出力されますが、配列やハッシュなどの複数の要素を持つオブジェクトの場合は改行が挿入されます。

```Ruby
puts 'Nakamura'
Nakamura
 => nil 			# 改行される
```

### print
引数として渡されたオブジェクトの文字列表現を改行なしで出力します。つまり、puts と異なり改行が挿入されず、複数の要素を持つオブジェクトでも改行されません。

```Ruby
print 'Nakamura'
Nakamura => nil 	# 改行されない
```

### p
引数として渡されたオブジェクトのデバッグ用の表現を出力します。つまり、オブジェクトの型や構造などがわかるような表現が出力されます。文字列は引用符で囲まれ、配列やハッシュなどは要素やキーと値が順番に出力されます。

```Ruby
p 'Nakamura'
"Nakamura"
 => "Nakamura" 		# 戻り値は引数
```

### pp
こちらもデバッグで使用できる。引数として渡されたオブジェクトを、改行やインデントを含めて整形して出力します。つまり、複数の要素を持つオブジェクトを見やすく表示するために用いられます。pが見づらいときにppを試してみるとよいらしい。pp は pretty-print の略です。

```Ruby
pp 'Nakamura'
"Nakamura"
 => "Nakamura" 		# 見た目はpと変わりないように思うが、適切なインデントと改行で整形される
```

## 繰り返し処理
### 概要
いろいろな記述方法がありますが、どちらを使用するかは、実装のコンテキストによって異なります。
- each
- for
- times
- while
- upto, downto
- step
- loop, break, next

一番よく使うのはeachらしい

### ぱっと見
```Ruby
- each
	配列やハッシュ.each do |変数|
		# 繰り返し実行したい処理
	end


- for
- times
- while
- upto, downto
- step
- loop, break, next
```


### each
#### 構文
```Ruby
配列やハッシュ.each do |変数|
	# 繰り返し実行したい処理
end
```
補足：配列の要素を最初から最後まで順番に取り出しながら処理を実行する

#### 記入例①
```Ruby
numbers = [1 ,2 ,3 ,4 ,5]
numbers.each do |number|
	puts number
end
```
補足：絶対的なルールではないが、配列の入っている要素は複数形、それぞれの値が入っている変数は単数形にすることが多い
#### 記入例②
```Ruby
numbers = [1 ,2 ,3 ,4 ,5]
numbers.each {|number|
	puts number
}
```

#### 記入例③
```Ruby
numbers = [1 ,2 ,3 ,4 ,5]
numbers.each {|number| puts number }
```

#### 表示結果
①～③いずれも表示結果は同じです
```Ruby
1
2
3
4
5
```

#### 記入例④
```Ruby
fruits = ['apple' ,'banana' ,'lemon']
fruits.each do |fruit|
	puts fruit
end
```

#### 表示結果
```Ruby
apple
banana
lemon
```

### each (ハッシュ利用)

#### 記入例
```Ruby
scores = {luke: 100, jack: 90, robert: 70}
scores.each do |k, v|		# key, value
	puts v
	puts "#{k}, #{v}"
	if v >= 80
		puts "#{k}, #{v}"
	end
end
```
※#{ } (式展開)を使用して、文字列の中に変数や式を挿入することができます。
#### 表示結果
```Ruby
100
luke, 100
luke, 100
90
jack, 90
jack, 90
70
robert, 70
```

### each (next利用)
#### 記入例
```Ruby
# 配列[1,2,3,4,5]の値が、奇数の場合のみ出力する
numbers = [1 ,2 ,3 ,4 ,5]
numbers.each do |number|
	next if number % 2 == 0
	# next if number.even?		## こちらの記述方法も可能
	puts number
end

# 配列[1,2,3,4,5]の値が、偶数の場合のみ出力する
numbers.each do |number|
	next if number % 2 != 0
	# next if number.odd?		## こちらの記述方法も可能
	puts number
end
```
#### 表示結果
```Ruby
1	# 奇数のみ
3
5
2	# 偶数のみ
4
```

### each (xからyまで繰り返す)
#### 記入例
```Ruby
def sheep(n)
	(1..n).each {
		|i| puts "羊が#{i}匹"
	}	
end
sheep(5)
```
uptoいらんやん…

eachは要素を取り出すイメージらしいので、uptoとは違うのだろうか？

↓GPTより

>実行速度という観点で比較すると、eachメソッドとuptoメソッドのどちらが速いかは、使用する要素の数や処理の内容によって異なるため一概には言えません。  
>ただし、uptoメソッドは、指定した値までの数値を順番に処理する場合に適したメソッドであり、プログラムの可読性が高く、処理の意図が明確に表現できるというメリットがあります。一方、eachメソッドは、要素を順番に処理する場合に適しているため、それ以外の場合には向いていないことがあります。

#### 表示結果
```Ruby
羊が1匹
羊が2匹
羊が3匹
羊が4匹
羊が5匹
```

### for
#### 構文
```Ruby
for 変数 in 配列やハッシュ do
	# 繰り返し実行したい処理
end
```
ただし、forは原則使わない  
慣習としてeachでもforでも書けるときは、eachを用いる

>`for`は、どうしても使わなければいけない明確な理由が明言できる人以外は、使ってはいけません。 多くの場合は代わりにイテレータを使うべきです。 `for`は`each`をつかって実装されています(だから、より遠回しです)が、 forは(eachと違い)新しいスコープを導入せず、 そのブロック内で定義された変数は、ブロックの外からも見えます。

[出典：rubocop/rails-style-guide（日本語訳）](https://github.com/fortissimo1997/ruby-style-guide/blob/japanese/README.ja.md#no-for-loops)

#### 記入例
```Ruby
numbers = [1 ,2 ,3 ,4 ,5]
for number in numbers do
	puts number
end
```
#### 表示結果
```Ruby
1
2
3
4
5
```

### times
配列を使わずに、単純にn回処理をくり返したい場合は、Integerクラスのtimesメソッドを使うと便利です

#### 構文
```Ruby
繰り返し回数.times do |i|
	# 繰り返し実行したい処理
end
```
iの変数名は任意でつけられます  
|i|は省略可能です

#### 記入例
```Ruby
5.times do |i|
	print "#{i}: "		# あえて変数iの値を出力している
	puts "Hello!"
end
```
eachの場合と同様にdo～endは{ }表記に置き換え可能です
#### 表示結果
```Ruby
0: Hello!			# 変数iは0から始まっている
1: Hello!
2: Hello!
3: Hello!
4: Hello!
```

### while
条件が真である場合に繰り返し処理をする
#### 構文
```Ruby
while 条件式 do
	# 繰り返し実行したい処理
end
```
#### 記入例
```Ruby
i = 0
while i < 10 do
	puts i
	i += 1
end
```
無限ループにご注意☆

#### 表示結果
```Ruby
0
1
2
3
4
5
6
7
8
9
```

### upto, downto
- upto

nからmまで数値を1ずつ増やしながら何かしらの処理を実行したい場合に使う

- downto

nからmまで数値を1ずつ減らしながら何かしらの処理を実行したい場合に使う
#### 構文
```Ruby
# upto
開始値.upto(終了値) { 繰り返し実行したい処理 }

# downto
開始値.downto(終了値) { 繰り返し実行したい処理 }
```
#### 記入例
```Ruby
# 数値を10から14まで1ずつ増やしながら、値を出力する
10.upto(14) { |n| puts n }

# 数値を14から10まで1ずつ減らしながら、値を出力する
14.downto(10) { |n| puts n }
```
#### 表示結果
```Ruby
10	# upto
11
12
13
14
14	# downto
13
12
11
10
```

### step
nからmまでxずつ値を増やしながら、難かしらの処理を実行したい時に利用する

例) 1, 3, 5, 7, 9

#### 構文
```Ruby
開始式.step(上限値, 一度に増減する大きさ){}
```
#### 記入例
```Ruby
# 数値を1から10まで3ずつ増やしながら出力する
1.step(10, 3) { |n| puts n }

# 数値を20から1まで5ずつ減らしながら出力する
20.step(1, -5) { |n| puts n }
```
#### 表示結果
```Ruby
1	# 3ずつ増加
4
7
10
20	# 5ずつ減少
15
10
5
```

### loop, break, next
- loop

あえて無限ループを作りたい時に利用する

#### 構文
```Ruby
loop do
	# 繰り返し実行したい処理
end
```

#### 記入例①
```Ruby
# 変数の値を0から1ずつ増やしながら出力する
# 無限ループするのでCtrl + Cで強制終了する。(少し時間がかかります)
i = 0
loop do
	puts i
	i += 1
end
```
#### 表示結果①
```Ruby
1
2
3
4
5
…無限に1ずつ増加
```

#### 記入例②
breakでloopを抜ける
```Ruby
i = 0
loop do
	puts i
	i += 1
	break if i == 10
end
```
#### 表示結果②
```Ruby
0
1
2
3
4
5
6
7
8
9
```




<!-- ### 【少しブレイク】GPTとの雑談
「構文」と「記述方法」は同じ意味でしょうか

>「構文」と「記述方法」は意味が異なる概念です。

>「構文」とは、プログラムの文法に従って正しく記述されたプログラムの文の形式や構造を指します。例えば、Rubyの場合は if 文の構文は if 条件 then 処理1 else 処理2 end となっており、この形式に従わないプログラムは構文エラーとなります。

>一方、「記述方法」とは、プログラムを書く際の手法やスタイルのことを指します。例えば、コードのインデントを揃えたり、変数名やメソッド名に規則性を持たせたりすることが挙げられます。これらは構文的に正しいかどうかに関わらず、コードの読みやすさやメンテナンス性などを向上させるために行われます。 -->

## 総和


## 3. 総和
1 から 100 までの足し算の結果を出力する関数 sum_1_100 を定義してください。
▼インプット
入力はありません。
▼アウトプット
1 から 100 までの足し算の結果を出力してください。
▼サンプル呼び出し
```ruby
sum_1_100()
```
▼サンプルアウトプット
```ruby
5050
```
▼回答例_Ruby
```ruby
def sum_1_100
  # 関数を完成させてください
end
```

def sum_1_100
puts (1..100).sum
end

sum_1_100()
def sum_1_100
  result = 0
  1.upto(100) { |n| result += n } 
  puts result
end
sum_1_100()


## 4. 総和
2つの整数 x と y が与えられ、x から y までの足し算の結果を出力する関数 sum を定義してください。
▼インプット
```ruby
x：整数
y：整数
1 <= x, y <= 100
```
▼アウトプット
x から y までの足し算の結果を出力してください。
▼サンプル呼び出し
```ruby
sum(10, 80)
```
▼サンプルアウトプット
```ruby
3195
```
▼回答例_Ruby
```ruby
def sum(x, y)
  # 関数を完成させてください
end
```

def swap(x, y)
  if y < x
    x, y = y, x
  end
  return x, y
end


def sum(x, y)
  if y < x
    x, y = y, x
  end
  
  result = 0
  x.upto(y) { |i| result += i }
  puts result
end

sum(10,80)



## フィボナッチ数列


家のお手伝いを毎日継続すると、継続日数 n 日に応じて、その日にもらえるお小遣いの金額が増えていきます。お小遣いの金額は以下の条件に従ってもらうことができます。
f(0) = 0 円
f(1) = 1 円
f(n) = f(n-1) + f(n-2) 円   (n ≧ 2)
整数 n に対して、n 日間お手伝いを継続した時のお小遣いの金額を算出する関数 fibonacci を定義してください。
▼インプット
```ruby
n：整数
1 <= n <= 30
```
▼アウトプット
お小遣いの金額を出力してください。
▼サンプル呼び出し
```ruby
fibonacci(0)
fibonacci(1)
fibonacci(2)
fibonacci(3)
fibonacci(4)
fibonacci(7)
fibonacci(30)
```
▼サンプルアウトプット
```ruby

0
1
1
2
3
13
832040
```
▼回答例_Ruby
```ruby
def fibonacci(n)
  # 関数を完成させてください
end
```
このプログラムは、与えられた引数 n に対して、
フィボナッチ数列の第 n 項を計算して返す関数です。
フィボナッチ数列とは、最初の2つの数が0と1で、
その後の項は前の2つの項の和となる数列です。
例えば、最初の数項は0, 1, 1, 2, 3, 5, 8, 13, 21, ... と続きます。

def fibonacci(n)
  
  case n
  when 0 
    puts 0
  when 1
    puts 1
  else
    fib1 = 0
    fib2 = 1
    2.upto(n) {
      fib = fib1 + fib2
      fib1 = fib2
      fib2 = fib
    }
    puts fib2
  end
end

fibonacci(0)
fibonacci(1)
fibonacci(2)
fibonacci(3)
fibonacci(4)
fibonacci(5)
fibonacci(6)
fibonacci(7)
fibonacci(30)

## 配列
複数のデータをまとめて格納できるオブジェクトのこと

配列内のデータ (要素) は順番に並んでいて、添え字 (インデックス) を指定することでデータを取り出せる

### irbを使って配列を学習
```Ruby
$ irb
# 配列aを定義
2.6.3 :001 > a = [1 ,2 ,3 ,'aa' , [1,2,3] ]
 => [1, 2, 3, "aa", [1, 2, 3]] 

# 配列の値を取り出す
2.6.3 :002 > a[0]
 => 1 

2.6.3 :003 > a[1]
 => 2 

# 配列を出力する
2.6.3 :004 > puts a
1
2
3
aa
1
2
3
 => nil 

2.6.3 :005 > p a
[1, 2, 3, "aa", [1, 2, 3]]
 => [1, 2, 3, "aa", [1, 2, 3]] 

2.6.3 :006 > pp a
[1, 2, 3, "aa", [1, 2, 3]]
 => [1, 2, 3, "aa", [1, 2, 3]] 

# 配列が空かどうか確かめる
2.6.3 :007 > a.empty?
 => false 

2.6.3 :008 > b = []
 => [] 

2.6.3 :009 > b.empty?
 => true 


# 配列にある要素が含まれているか
2.6.3 :010 > a.include?('aa')
 => true 

2.6.3 :011 > a.include?('b')
 => false 

# 配列を反転
2.6.3 :012 > a.reverse
 => [[1, 2, 3], "aa", 3, 2, 1] 

2.6.3 :013 > a
 => [1, 2, 3, "aa", [1, 2, 3]] 

# 破壊的メソッド
2.6.3 :014 > a.reverse!
 => [[1, 2, 3], "aa", 3, 2, 1] 

2.6.3 :015 > a
 => [[1, 2, 3], "aa", 3, 2, 1] 

# シャッフル
2.6.3 :016 > a.shuffle
 => [[1, 2, 3], 2, 3, "aa", 1] 

# 0～25の要素をもつ配列を定義
2.6.3 :017 > (0..25).to_a
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25] 

2.6.3 :018 > aa = (0..10).to_a.shuffle!
 => [2, 0, 6, 10, 8, 5, 9, 1, 7, 4, 3] 

2.6.3 :019 > aa
 => [2, 0, 6, 10, 8, 5, 9, 1, 7, 4, 3] 

2.6.3 :020 > z = (0..10).to_a
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

# 配列の最後に要素を追加
2.6.3 :021 > z << 20
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20] 

2.6.3 :022 > z
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20] 

# 配列の最後に要素を追加  上記<<と同じ
2.6.3 :023 > z.push(30)
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30] 

# 配列の末尾の要素を削除し、その要素を返す
2.6.3 :024 > z.pop
 => 30 

2.6.3 :025 > z
 => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20] 

# 配列の最初の要素を削除し、その要素を返す
2.6.3 :026 > z.shift
 => 0 

2.6.3 :027 > z
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20] 

2.6.3 :028 > z << 3
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 3] 

2.6.3 :029 > z << 6
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 3, 6] 

# 重複する要素を排除した配列を返す
2.6.3 :030 > z.uniq
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20] 

2.6.3 :031 > z
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 3, 6] 

2.6.3 :032 > z.uniq!
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20] 

2.6.3 :033 > z
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20] 

2.6.3 :034 > s = ['my', 'name', 'is', 'tamako']
 => ["my", "name", "is", "tamako"] 

# 結合する
2.6.3 :035 > s.join
 => "mynameistamako" 

# 見やすくするためにセパレータを指定する
2.6.3 :036 > s.join(' ')
 => "my name is tamako" 

2.6.3 :037 > s.join('_')
 => "my_name_is_tamako" 

# ソートする
2.6.3 :038 > s.sort
 => ["is", "my", "name", "tamako"] 

2.6.3 :039 > s.sort.reverse
 => ["tamako", "name", "my", "is"] 

2.6.3 :040 > s.sort!.reverse!
 => ["tamako", "name", "my", "is"] 

2.6.3 :041 > s
 => ["tamako", "name", "my", "is"] 

# 配列の要素数
2.6.3 :042 > s.size
 => 4 
```

## ハッシュ
キー (Key) と値 (Value)の組み合わせでデータを管理するオブジェクト

連想配列、ディクショナリ、マップと言う場合もある


### irbを使ってハッシュを学習
```Ruby
$ irb
# 空のハッシュを作成
2.6.3 :001 > {}
 => {} 

# ハッシュを宣言して初期値として変数に代入する
2.6.3 :002 > huguta = {'name' => 'huguta', 'birthplace' => 'Tokyo'}
 => {"name"=>"huguta", "birthplace"=>"Tokyo"} 

# ハッシュからキーを取り出す
2.6.3 :003 > puts huguta['name']
huguta
 => nil 

# 値を追加する
2.6.3 :004 > huguta['age'] = 24
 => 24 

2.6.3 :006 > puts huguta
{"name"=>"huguta", "birthplace"=>"Tokyo", "age"=>24}
 => nil 

# 値を変更する
2.6.3 :007 > huguta['age'] = 21
 => 21 

2.6.3 :008 > puts huguta
{"name"=>"huguta", "birthplace"=>"Tokyo", "age"=>21}
 => nil 

# キーを指定して値を削除する
2.6.3 :009 > huguta.delete('age')
 => 21 

2.6.3 :010 > puts huguta
{"name"=>"huguta", "birthplace"=>"Tokyo"}
 => nil 

```
#### シンボルとは
ソースコード上では文字列のように見えるが、内部では整数として扱われる

>シンボルを表すクラス。シンボルは任意の文字列と一対一に対応するオブジェクトです。  

>文字列の代わりに用いることもできますが、必ずしも文字列と同じ振る舞いをするわけではありません。同じ内容のシンボルはかならず同一のオブジェクトです。

>実用面では、シンボルは文字の意味を明確にします。`名前'を指し示す時など、文字列そのものが必要なわけではない時に用います。

>- ハッシュのキー { :key => "value" }
>- アクセサの引数で渡すインスタンス変数名 attr_reader :name
>- メソッド引数で渡すメソッド名 __send__ :to_s
>- C の enum 的な使用 (値そのものは無視してよい場合)

>シンボルを使うメリットは
>- 新しく文字列を生成しない分やや効率がよく、比較も高速。
>- 文字の意味がはっきりするのでコードが読みやすくなる
>- immutable なので内容を書き換えられる心配がない
[Ruby 3.2 リファレンスマニュアル  class Symbol](https://docs.ruby-lang.org/ja/latest/class/Symbol.html)

よくわからない。→

```Ruby
# シンボルを使ってハッシュを定義する
2.6.3 :011 > isono = {name: 'Isono', birthplace: 'Osaka'}
 => {:name=>"Isono", :birthplace=>"Osaka"} 

# ハッシュからキーを取り出す
2.6.3 :012 > puts isono[:name]
Isono
 => nil 

# 値を追加する
2.6.3 :014 > isono[:age] = 20
 => 20 

2.6.3 :015 > puts isono
{:name=>"Isono", :birthplace=>"Osaka", :age=>20}
 => nil 

# 値を変更する
2.6.3 :016 > isono[:age] = 24
 => 24 

2.6.3 :017 > puts isono
{:name=>"Isono", :birthplace=>"Osaka", :age=>24}
 => nil 

# キーを指定して値を削除する
2.6.3 :018 > isono.delete(:age)
 => 24 

2.6.3 :019 > puts isono
{:name=>"Isono", :birthplace=>"Osaka"}
 => nil 

# ハッシュが持っているキー一覧を取得する
2.6.3 :020 > isono.keys
 => [:name, :birthplace] 

# ハッシュが持っているバリュー一覧を取得する
2.6.3 :021 > isono.values
 => ["Isono", "Osaka"] 

# ハッシュが指定したキーを持っているか確認する
2.6.3 :022 > isono.has_key?(:name)
 => true 

2.6.3 :023 > isono.has_key?(:address)
 => false 

# ハッシュのサイズを求める
2.6.3 :024 > isono.size
 => 2 

```

## 補足
どの分野かよくわかってない

eachは少し前に出てきた気がする

### eachメソッド
配列やハッシュの要素を順番に取り出して、その要素に対してブロックを実行するためのメソッドです。eachメソッドは、繰り返し処理によく使用されます。
```Ruby
# 配列の要素を取り出す
fruits = ["apple", "banana", "orange"]
fruits.each do |fruit|
  puts fruit
end

# => "apple"
# => "banana"
# => "orange"

```

### with_indexメソッド
with_indexメソッドは、eachメソッドと同様に、配列やハッシュの要素を順番に取り出してブロックを実行するためのメソッドです。ただし、with_indexメソッドは、要素のインデックス値も一緒に渡すことができます。
```Ruby
# 配列の要素とインデックス値を取り出す
fruits = ["apple", "banana", "orange"]
fruits.each.with_index do |fruit, i|
  puts "#{i}: #{fruit}"
end

# => "0: apple"
# => "1: banana"
# => "2: orange"

```

### mapメソッド
mapメソッドは、配列やハッシュの要素に対して、ブロックを実行して新しい配列を作成するためのメソッドです。mapメソッドは、元の配列やハッシュを変更せずに、新しい配列を作成するため、元のデータを保持したまま別の形式で表示する場合に便利です。
```Ruby
# 配列の要素を大文字にして新しい配列を作成する
fruits = ["apple", "banana", "orange"]
upcase_fruits = fruits.map do |fruit|
  fruit.upcase
end

puts upcase_fruits
# => ["APPLE", "BANANA", "ORANGE"]

```

### Selectメソッド
selectメソッドは、配列やハッシュの要素のうち、ある条件を満たす要素だけを取り出すためのメソッドです。選択された要素は、新しい配列として返されます。条件は、ブロック内に記述されます。ブロック内の条件が真に評価された要素が選択されます。
```Ruby
# 配列から偶数だけを取り出す
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = numbers.select do |n|
  n % 2 == 0
end
puts even_numbers #=> [2, 4, 6]

# ハッシュから特定のキーだけを取り出す
person = {name: "John", age: 25, gender: "male"}
selected_person = person.select do |key, value|
  key == :name || key == :age
end
puts selected_person #=> {:name=>"John", :age=>25}

```

### 【悲報】ハッシュとシンボルが混同していて違いがわかりません。


Rubyにおいて、`ハッシュ`と`シンボル`は異なる機能を持つデータ型です。

`シンボル`は、Rubyのオブジェクトの一種であり、文字列と似たようなものですが、いくつかの重要な違いがあります。

まず、`シンボル`は任意の文字列と一対一に対応するオブジェクトであり、Rubyの内部では**整数**として表現されます。  
つまり、同じ内容の`シンボル`は必ず同一のオブジェクトであるため、メモリ効率が良く、比較演算子を使用した場合の処理速度が文字列よりも**高速**です。

例えば、以下のように`シンボル`と文字列を比較すると、文字列の場合は内容が同じでも別々のオブジェクトとして扱われますが、
`シンボル`の場合は同じオブジェクトとして扱われます。

```Ruby
str1 = "hello"
str2 = "hello"
sym1 = :hello
sym2 = :hello

puts str1.object_id == str2.object_id # => false
puts sym1.object_id == sym2.object_id # => true
```

次に、`シンボル`は文字列と比較して不変なため、変更される心配がありません。  
これにより、キーとして使用するときに値が誤って変更される心配がなくなり、安全に利用することができます。

最後に、実用面では、`シンボル`は文字列の代わりに用いることができますが、必ずしも文字列と同じ振る舞いをするわけではありません。例えば、文字列は可変であり、大文字小文字の違いがあるため、比較演算子を使用する場合には注意が必要です。一方、`シンボル`は不変であり、大文字小文字を区別しないため、比較演算子を安全に使用することができます。また、`シンボル`はメソッド名や定数名など、文字列そのものが必要なわけではない時にも用いられます。

代替案としては、文字列を使うことが考えられますが、メモリの使用効率や比較演算子の処理速度が悪くなるため、特にキーとして使用する場合にはシンボルを使うことが一般的です。
ハッシュは、キーと値をペアにして格納するデータ構造であり、`シンボル`は、不変な文字列を表すオブジェクトです。

ハッシュのキーに`シンボル`を使うことがよくあります。この場合、キーとして使用される`シンボル`は、文字列よりも軽量であり、ハッシュの性能向上につながります。  
また、`シンボル`は値が変わらないため、キーとして使うことで、間違って値が変更されることを防止することができます。

以下は、ハッシュとシンボルを使った例です。

```Ruby
# ハッシュの例
user = {
  name: "Alice",
  age: 30,
  email: "alice@example.com"
}

puts user[:name] # => "Alice"

# シンボルの例
status = :success

case status
when :success
  puts "Success!"
when :error
  puts "Error!"
else
  puts "Unknown status"
end
```

上記の例では、ハッシュの例では、キーにシンボルを使用しています。

また、シンボルの例では、case文の条件にシンボルを使用しています。

どちらの例でも、シンボルは文字列と同じように使われていますが、文字列と比較して軽量であり、コードのパフォーマンス向上につながります。