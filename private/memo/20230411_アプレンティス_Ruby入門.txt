20230411
・	Ruby入門

serverside-apprentice/skilldoc/technologies/RUBY.md
Level1

・	Rubyプログラムを実行する方法
	1.	irb（Interactive Ruby）を利用
		irbと入力してエンター
		puts 'Hello World'
		
	※	nilとは
		Rubyプログラムでは、最後に評価された式の値が返されます。しかし、何も返す値がない場合には、Rubyはデフォルトでnilを返します。nilはRubyにおける「何もないことを表すオブジェクト」であり、nullに近い概念です。nilは、オブジェクト指向プログラミングにおいて、ある変数が何も参照していないことを示すために利用されます。例えば、変数に何も代入されていない場合には、その変数はnilを参照していると言えます。
		
	2.	ファイルに保存したプログラムを実行
		mkdir ~~~~~~
		cdでフォルダへ移動
		ファイル作成
		touch hello.rb
		
Q.	ubuntuでフォルダを同階層の別フォルダへ移動するコマンドを教えてください。
		mv /path/to/source/folder /path/to/destination/folder
		mv source destination
	※	sourceとdestinationは、実際のパスに置き換える必要があります。
		また、destinationフォルダが存在しない場合は、新しく作成されます。
		↓これでできた
		mv ruby_study/ environment/

・	変数名の命名規則
		アルファベットの小文字、またはアンダースコアで始まる
		それに続けてアルファベット、数字、アンダースコアで記述する。
		予約語は使えない。
		
		よくない変数の使い方
			エラーでは無いが、メンテナンス性が悪くなるため、推奨されない変数の使い方について
		・	同じ変数に様々な型の値を入れて使いまわす。
		・	変数に複数の値を代入する　ex. i, j = 1, 2
		・	同時に複数変数に同じ値を代入する　ex. a = b = 10　※たまに見るスタイルではある。

・	定数
		ex.手数料率、消費税率、バージョン、デフォルトの価格、円周率。
		大文字を使用。
		TAX_RATE = 1.08
		定数への再代入はしないように。
		
・	リテラル
		数値の123や、文字列の'Hello World!'など、
		Rubyのプログラムの中に直接 記述できる値の事をリテラルという。
		リテラルの例
			123
			'Hello World'
			配列
				[1,2,3]
			ハッシュ（連想配列）
				{ 'red' => '#ff0000' , 'green' => '00ff00' , 'blue' => '0000ff'}

・	ざっくりオブジェクト指向概要
		オブジェクトとは
			データと処理の集まりのこと。
		オブジェクト指向とは
			オブジェクト同士が相互に関係しあうことで、システムの振る舞いをとらえる考え方。
		クラスとは
			オブジェクトの設計図
		インスタンス
			クラス（設計図）から作成した、実態。
		メソッド
			クラスの中に定義されているもので、複数の処理を一つにまとめて、扱いやすくしたもの。
			クラスに所属する関数のようなもの

・	動的型付け
		変数に値を代入する時に、動的型付けがされる
		変数の方指定を変数の宣言時に行う必要なし
			OK:
				i = 1
			NG:
				int i = 0
				
・	リテラル
		> x = 1
		 => 1 
		> -x
		 => -1 
		> 3 / 2
		 => 1 
		> 3.0 / 2
		 => 1.5 
		> 3 / 2.0
		 => 1.5 
		> 3.0 / 2.0
		 => 1.5 
		> 10 % 3
		 => 1 
		> 10 ** 3
		 => 1000 
		> x = 3
		 => 3 
		> x.to_f
		 => 3.0 
		> x.to_f / 2
		 => 1.5 
		> x / 2
		 => 1 
		> y = 2
		 => 2 
		> x / y.to_f
		 => 1.5 
		> x.to_f / y
		 => 1.5 
		> x.to_f / y.to_f
		 => 1.5 
		# 数値（ex.「1」「1.1」）が何の数値オブジェクトか調べる方法
		> 1.class
		 => Integer 
		> 1.1.class
		 => Float 
		# 数値オブジェクトがどのような機能を持っているか。使える機能を確認する方法。
		> 1.methods
		 => [:-@, :**, :<=>, :upto, :<<, :<=, :>=, :==, :chr, :===, :>>, :[], :%, :&, :inspect, :+, :ord, :-, :/, :*, :size, :succ, :<, :>, :to_int, :coerce, :divmod, :to_s, :to_i, :fdiv, :modulo, :remainder, :abs, :magnitude, :integer?, :numerator, :denominator, :rationalize, :to_r, :floor, :ceil, :round, :truncate, :lcm, :to_f, :^, :odd?, :even?, :allbits?, :anybits?, :nobits?, :downto, :times, :pred, :pow, :bit_length, :digits, :gcd, :gcdlcm, :next, :div, :|, :~, :+@, :eql?, :singleton_method_added, :i, :real?, :zero?, :nonzero?, :finite?, :infinite?, :step, :positive?, :negative?, :rectangular, :rect, :arg, :real, :imag, :imaginary, :angle, :abs2, :conjugate, :to_c, :polar, :conj, :phase, :clone, :dup, :quo, :between?, :clamp, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :instance_variable_get, :public_methods, :instance_variables, :public_method, :singleton_method, :method, :define_singleton_method, :public_send, :extend, :to_enum, :enum_for, :pp, :=~, :!~, :respond_to?, :freeze, :object_id, :send, :display, :nil?, :hash, :class, :singleton_class, :itself, :yield_self, :tainted?, :taint, :untrust, :untaint, :trust, :untrusted?, :methods, :frozen?, :protected_methods, :singleton_methods, :private_methods, :!, :equal?, :instance_eval, :instance_exec, :!=, :__id__, :__send__] 
		 
・	文字列
		''または""
		ただし、文字列の中に特殊文字（\n（改行）とか）がある場合は""
		式展開も""を使用する。
		
		> first_name = 'Yuta'
		 => "Yuta" 
		> last_name = 'Nakamura'
		 => "Nakamura" 
		# 式展開
		> puts "My name is #{first_name} #{last_name}."
		My name is Yuta Nakamura.
		 => nil 
		# シングルクォーテーションでは、式展開できない。
		> puts 'My name is #{first_name} #{last_name}.'                    
		My name is #{first_name} #{last_name}.
		 => nil 
		 
		> puts 'Yuta' + 'Nakamura'
		YutaNakamura
		 => nil 
		> puts 'Yuta' + ' ' + 'Nakamura'                                   
		Yuta Nakamura
		 => nil 
		> s = 'Hello, World!'
		 => "Hello, World!" 
		# 大文字で出力
		> puts s.upcase
		HELLO, WORLD!
		 => nil 
		# upcaseでも変数sが変わっていない
		> puts s
		Hello, World!
		 => nil 
		
		# 破壊的編集「!」を付ける。大文字のまま変数内容が保存される。
		> s.upcase!
		 => "HELLO, WORLD!" 
		> puts s
		HELLO, WORLD!
		 => nil 

		> 'abc'.class
		 => String 

		> 'abc'.methods
		 => [:encode!, :include?, :%, :*, :+, :count, :partition, :to_c, :sum, :next, :casecmp, :casecmp?, :insert, :bytesize, :match, :match?, :succ!, :<=>, :next!, :index, :rindex, :upto, :==, :===, :chr, :=~, :byteslice, :[], :[]=, :scrub!, :getbyte, :replace, :clear, :scrub, :empty?, :eql?, :-@, :downcase, :upcase, :dump, :setbyte, :swapcase, :+@, :capitalize, :capitalize!, :undump, :downcase!, :oct, :swapcase!, :lines, :bytes, :split, :codepoints, :freeze, :inspect, :reverse!, :grapheme_clusters, :reverse, :hex, :scan, :upcase!, :crypt, :ord, :chars, :prepend, :length, :size, :start_with?, :succ, :sub, :intern, :chop, :center, :<<, :concat, :strip, :lstrip, :end_with?, :delete_prefix, :to_str, :to_sym, :gsub!, :rstrip, :gsub, :delete_suffix, :to_s, :to_i, :rjust, :chomp!, :strip!, :lstrip!, :sub!, :chomp, :chop!, :ljust, :tr_s, :delete, :rstrip!, :delete_prefix!, :delete_suffix!, :tr, :squeeze!, :each_line, :to_f, :tr!, :tr_s!, :delete!, :slice, :slice!, :each_byte, :squeeze, :each_codepoint, :each_grapheme_cluster, :valid_encoding?, :ascii_only?, :rpartition, :encoding, :hash, :b, :unicode_normalize!, :unicode_normalized?, :to_r, :force_encoding, :each_char, :encode, :unicode_normalize, :unpack, :unpack1, :<=, :>=, :between?, :<, :>, :clamp, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :instance_variable_get, :public_methods, :instance_variables, :public_method, :singleton_method, :method, :define_singleton_method, :public_send, :extend, :to_enum, :enum_for, :pp, :!~, :respond_to?, :object_id, :send, :display, :nil?, :class, :singleton_class, :clone, :dup, :itself, :yield_self, :tainted?, :taint, :untrust, :untaint, :trust, :untrusted?, :methods, :frozen?, :protected_methods, :singleton_methods, :private_methods, :!, :equal?, :instance_eval, :instance_exec, :!=, :__id__, :__send__] 

・	空白文字
		スペースを何個入れても動作は変わらない。
		可読性のために空白を活用しよう。
		
・	演算子の優先順位
		公式リファレンス＞演算子式

・	数値と文字列は暗黙に変換されない
		> 1 + '1'
		Traceback (most recent call last):
		        3: from /usr/local/rvm/rubies/ruby-2.5.1/bin/irb:11:in `
		'
		        2: from (irb):1
		        1: from (irb):1:in `+'
		TypeError (String can't be coerced into Integer)
		> 1 + '1'.to_i
		 => 2 
		> 1 + '1.1'.to_f
		 => 2.1 
		> number = 1
		 => 1 
		> 'Number is' + number
		Traceback (most recent call last):
		        3: from /usr/local/rvm/rubies/ruby-2.5.1/bin/irb:11:in `
		'
		        2: from (irb):5
		        1: from (irb):5:in `+'
		TypeError (no implicit conversion of Integer into String)
		> 'Number is ' + number.to_s                                       
		 => "Number is 1" 

・	関数のサンプルコードの書き方について
		.rbファイルを作成する
		def～endで関数を定義する
		同じファイル内で呼び出しのコードを書く
		保存して、ruby ○○.rbコマンド実行
		
	※	サンプル
		def add(x,y)
		  return x + y
		end
		result = add(3 , 5)
		puts result #=> 8
	※	#=> は、Rubyのコードの出力結果をコメントとして表現する方法の一つです。
		# は行コメントを表す記号で、=> はハッシュマップのキーと値を表す記号としても使われますが、#=> の場合は、コードの実行結果を示すために用いられます。
		このように、#=> を使ってコードの出力結果をコメントとして書くことで、コードの動作を説明しやすくなります。
		
		関数を定義したファイルとは別のファイルからでも、その関数を呼び出すことができます。
		ただし、呼び出す際には定義したファイルを読み込む必要があります。
		例えば、sample.rb というファイルに greet という関数を定義したとします。
		def greet(name)
		  puts "Hello, #{name}!"
		end

		このファイルを別のファイルから読み込み、greet 関数を呼び出す場合は、以下のようにします。
		require './sample.rb' # 定義したファイルを読み込む

		greet('Alice') # Hello, Alice! と出力される

・	【余談】さくらエディタをデフォルトアプリに設定する方法（Win11）
		適当にテキストファイルを作って保存
		右クリック＞プログラムから開く＞別のプログラムを選択
		さくらエディタを選択し、「常に使う」をクリック
		.txtファイルのロゴ?がさくらエディタに替わっていればOK

・	プログラムを実行して値を入力させる方法
		例
		puts "何か入力してください:"
		input = gets.chomp
		puts "入力された値は #{input} です"
		# chomp メソッドは、文字列の末尾にある改行文字（"\n"）を削除します。Rubyで gets メソッドを使用してユーザーからの入力を受け取る場合、ユーザーがEnterキーを押すことで、改行文字が入力されることがあります。この改行文字が入力された場合、chomp メソッドを使用して、文字列から改行文字を削除することができます。
		# chomp は、英語の動詞 "chomp"（ちぎり取る、食べる、かじる）の現在分詞形であり、Rubyのメソッド名としても使われているため、日本語の読み方としては「チョンプ」と読むことが一般的です。

		# 例えば、以下のように gets メソッドを使用して文字列を入力し、 chomp メソッドを使用して改行文字を削除することができます。
		# 公式リファレンス→instance method IO#gets
		https://docs.ruby-lang.org/ja/latest/method/IO/i/gets.html

・	メソッドを自作し使うことができる
		1. Hello World
		
			"Hello World" と標準出力（画面）に出力する関数 hello を定義してください。
			
			▼インプット

			入力はありません。

			▼アウトプット

			"Hello World" と出力してください。
			
			▼サンプル呼び出し

			hello()
			▼サンプルアウトプット

			Hello World
			▼回答例_Ruby

			def hello
				puts "Hello World"
			end
			
		2. 挨拶
		
			名前を引数に受け取り、与えられた名前の挨拶メッセージを標準出力（画面）に出力する greeting という関数を書きなさい。

			▼インプット

			name：文字列
			▼アウトプット

			"おはよう、◯◯！" と出力してください。

			▼サンプル呼び出し

			greeting('渡辺')
			▼サンプルアウトプット

			おはよう、渡辺！
			▼回答例_Ruby

			def greeting(name)
			  puts "おはよう、#{name}！"
			end

		※	上記のコードでは、greeting という名前の関数を定義し、引数 name に与えられた名前を挨拶メッセージに組み込んで標準出力に出力しています。
			関数は、def キーワードを使用して定義し、引数は括弧で囲みます。文字列内で変数を展開するために、#{} を使用します。
			
		※	Rubyでのコメントアウトには、行コメントアウトと複数行コメントアウトの2つがある。
			行コメントアウトは、#を行頭に記述し、その行の末尾までコメントにする。
			複数行コメントアウトは、=beginと=endを使ってコメントアウトする。
		※	=begin, =endは実務ではあまり使用されないらしい。
		※	コメントアウトのショートカットはCtrl + /


・	変数を宣言し代入することができる
		1. 三角形の面積
			底辺が x cm、高さが y cmの三角形の面積を出力する関数 area を定義してください。

			▼インプット

			x：整数
			y：整数

			1 <= x, y <= 100
			▼アウトプット

			面積を数値で出力してください。

			▼サンプル呼び出し

			area(5, 4)
			▼サンプルアウトプット

			10
			▼回答例_Ruby

			def area(x, y)
			  x * y / 2
			end

・【補足】unless
		ifと反対の使い方である
		無理にunlessを使う必要はない。
		読みやすいと思う場合はifでOK。
		unless 条件式
			# 条件式がfalseのとき、実行したい処理。
		else
			# 条件式がfalseでない場合、つまりtrueの時に実行したい処理。
		end
		
		※elsifに相当するものは無い。
		
		例題①
		変数nの値が 0でなければ、"Not zero."と出力する
		※値が0か判定するには、zero? メソッドが使える。
		
		# 例題①
			# n = 1
			# if !n.zero?
			#   puts 'Not zero.'
			# end

		## 例題②, ③
			n = 1
			unless n.zero?
			  puts 'Not zero.'
			else
			  puts 'This is zero.'
			end
		
・	条件分岐を使うことができる
		1. 比較
			2つの整数 x, y の大小を比較し、xとyの大小関係を出力する関数 greater を定義してください。

			▼インプット

			x：整数
			y：整数

			-100 <= x, y <= 100
			▼アウトプット

			xよりyが大きければ「x > y」 xよりyが小さければ「x < y」 xとyの値が同じなら「x == y」

			▼サンプル呼び出し

			greater(5, 4)
			greater(-50, -40)
			greater(10, 10)
			▼サンプルアウトプット

			x > y
			x < y
			x == y
			▼回答例_Ruby

			def greater(x, y)
			  if x > y
			    puts "x > y"
			  elsif x < y
			    puts "x < y"
			  else
			    puts "x == y"
			  end
			end

			
		2. 電車の料金
			東京駅から新宿駅までJR山手線に乗って移動します。12歳以上は大人料金で200円、6歳以上12歳未満はこども料金で100円、6歳未満は幼児で無料となります。年齢に応じて東京駅から新宿駅までの料金を出力する関数 train_fare を定義してください。

			▼インプット

			年齢 age が整数で与えられます。

			0 <= age <= 150
			▼アウトプット

			電車賃を出力してください。

			▼サンプル呼び出し

			train_fare(12)
			train_fare(6)
			train_fare(5)
			▼サンプルアウトプット

			200
			100
			0
			▼回答例_Ruby

			def train_fare(age)
			  case age
			  when 0..5
			    puts 0
			  when 6..11
			    puts 100
			  else
			    puts 200
			  end
			end

		
		3. XOR
			2つのブーリアン値 x と y が与えられ、x と y のうちどちらかが真なら true を出力し、両方真もしくは両方偽なら false を出力する関数 xor を定義してください。

			▼インプット

			x：ブーリアン値
			y：ブーリアン値
			▼アウトプット

			trueもしくはfalseを出力してください。

			▼サンプル呼び出し

			xor(true, true)
			xor(true, false)
			xor(false, true)
			xor(false, false)
			▼サンプルアウトプット

			puts xor(true, true)   #=> false
			puts xor(true, false)  #=> true
			puts xor(false, true)  #=> true
			puts xor(false, false) #=> false

			▼回答例_Ruby

			def xor(x, y)
			  if (x && !y) || (!x && y)
			    return true
			  else
			    return false
			  end
			end

		
・	繰り返し処理
		1. 挨拶
			100回 "こんにちは！" と出力する関数 hello を定義してください。

			▼インプット

			入力はありません。

			▼アウトプット

			"こんにちは！" という文字列を100行出力してください。

			▼サンプル呼び出し

			hello()
			▼サンプルアウトプット

			こんにちは！
			こんにちは！
			...
			こんにちは！
			▼回答例_Ruby

			def hello
			  100.times do
			    puts "こんにちは！"
			  end
			end
			# 関数の中で times メソッドを使用して、100回繰り返し処理を実行し、その中で puts メソッドを使用して文字列を出力しています。
			
			# 実行方法
			hello()

			参考まで
			Q.その他の方法でコード記述は可能でしょうか？例を3つあげてください。
			①do...end ブロックを使用する方法：
			def hello
			  100.times do
			    puts "こんにちは！"
			  end
			end

			②ワンライナーのメソッドを使用する方法：
			def hello; 100.times { puts "こんにちは！" }; end

			③for ループを使用する方法：
			def hello
			  for i in 1..100
			    puts "こんにちは！"
			  end
			end
			
			Q.上記の中で推奨される書き方はどれですか？
			Rubyの公式ドキュメントでも、1つ目の方法が推奨されています。
			特に、複数行のメソッドを定義する場合や、メソッドの中で条件分岐やループを行う場合には、この書き方が読みやすくなります。
			また、2つ目の方法は一部のライブラリで使用されていますが、可読性が低く、縦に長いコードになりがちなため、避けることが望ましいでしょう。
			3つ目の方法は、Rubyの標準機能として提供されていますが、関数の定義と呼び出しを区別することができず、可読性に欠けるため、あまり使われることはありません。

		2. 羊
			あなたは眠れなくなったので羊の数を数えることにしました。羊の数 n が与えられ

			羊が1匹 羊が2匹 羊が3匹 ...

			と、n 回羊の数えを出力する関数 sheep を定義してください。

			▼インプット

			n：整数

			1 <= n <= 100
			▼アウトプット

			"羊がn匹"と出力してください。

			▼サンプル呼び出し

			sheep(3)
			▼サンプルアウトプット

			羊が1匹
			羊が2匹
			羊が3匹
			▼回答例_Ruby
			①timesメソッドを使用する場合
			def sheep(n)
			  n.times { |i| puts "羊が#{i+1}匹" }
			end
			
			②for文を使用する場合
			def sheep(n)
			  for i in 1..n do
			    puts "羊が#{i}匹"
			  end
			end

			③eachメソッドを使用する場合
			def sheep(n)
			  (1..n).each { |i| puts "羊が#{i}匹" }
			end
			
			# 上記の3つの方法でどのようにコードを書いても同じ結果が得られますが、Rubyではtimesメソッドを使うことが一般的に推奨されています。なぜなら、timesメソッドは、for文やeachメソッドよりもシンプルで、かつ効率的であるためです。また、timesメソッドは、イテレーション回数を指定するだけで簡単にループを回すことができるため、コードの可読性も高くなります。
			④1.upto(n) メソッドを使用
			def sheep(n)
			  1.upto(n) do |i|
			    puts "羊が#{i}匹"
			  end
			end
			
			# Q.timesメソッドとuptoメソッドのどちらがより良いですか
			どちらを使用するかは、実装のコンテキストによって異なります。ただし、一般的には、実行する回数があらかじめ分かっている場合は、 times メソッドを使用し、そうでない場合は upto メソッドを使用することが推奨されます。

times メソッドは、0からn-1までの整数を数え上げるために使用されるため、具体的な回数が明確な場合に適しています。一方、uptoメソッドは、指定された整数まで数え上げるために使用され、数え上げる範囲が明確でない場合に使用されます。

たとえば、sheep関数の場合、nが明確に指定されているため、 times メソッドを使用することが適しています。しかし、より複雑なシナリオでは、コンテキストに基づいてどちらを使用するかを判断する必要があります。
			
		3. 総和
			1 から 100 までの足し算の結果を出力する関数 sum_1_100 を定義してください。

			▼インプット

			入力はありません。

			▼アウトプット

			1 から 100 までの足し算の結果を出力してください。

			▼サンプル呼び出し

			sum_1_100()
			▼サンプルアウトプット

			5050
			▼回答例_Ruby

			def sum_1_100
			  # 関数を完成させてください
			end
			
		4. 総和
			2つの整数 x と y が与えられ、x から y までの足し算の結果を出力する関数 sum を定義してください。

			▼インプット

			x：整数
			y：整数

			1 <= x, y <= 100
			▼アウトプット

			x から y までの足し算の結果を出力してください。

			▼サンプル呼び出し

			sum(10, 80)
			▼サンプルアウトプット

			3195
			▼回答例_Ruby

			①for文を使った方法
			def sum(x, y)
			  result = 0
			  for i in x..y
			    result += i
			  end
			  return result
			end

			②while文を使った方法
			def sum(x, y)
			  result = 0
			  i = x
			  while i <= y
			    result += i
			    i += 1
			  end
			  return result
			end

			③uptoメソッドを使った方法
			def sum(x, y)
			  result = 0
			  x.upto(y) do |i|
			    result += i
			  end
			  return result
			end
			# 推奨される書き方は、3番目のuptoメソッドを使った方法です。uptoメソッドはRubyの標準機能であり、xからyまでの繰り返しを行いながらブロック内の処理を行うため、繰り返し回数を数えるための変数が不要で、シンプルであるという利点があります。また、for文やwhile文を使った方法よりも、可読性が高く、コード量も少なくなります。
			
		5. フィボナッチ数列(advanced)
			家のお手伝いを毎日継続すると、継続日数 n 日に応じて、その日にもらえるお小遣いの金額が増えていきます。お小遣いの金額は以下の条件に従ってもらうことができます。

			f(0) = 0 円 f(1) = 1 円 f(n) = f(n-1) + f(n-2) 円 (n ≧ 2)

			整数 n に対して、n 日間お手伝いを継続した時のお小遣いの金額を算出する関数 fibonacci を定義してください。

			▼インプット

			n：整数

			1 <= n <= 30
			▼アウトプット

			お小遣いの金額を出力してください。

			▼サンプル呼び出し

			fibonacci(0)
			fibonacci(1)
			fibonacci(2)
			fibonacci(3)
			fibonacci(4)
			fibonacci(7)
			fibonacci(30)
			▼サンプルアウトプット

			0
			1
			1
			2
			3
			13
			832040
			▼回答例_Ruby

			①最も推奨される記述方法は、再帰関数を使用する方法です。
			def fibonacci(n)
			  return 0 if n == 0
			  return 1 if n == 1
			  return fibonacci(n-1) + fibonacci(n-2)
			end
			# この実装では、n が 0 の場合は 0 を返し、n が 1 の場合は 1 を返し、それ以外の場合は再帰的に呼び出している fibonacci(n-1) と fibonacci(n-2) の和を返しています。

			②次に、for文を使用する方法です。
			def fibonacci(n)
			  if n == 0
			    return 0
			  elsif n == 1
			    return 1
			  else
			    fibs = [0, 1]
			    for i in 2..n
			      fibs[i] = fibs[i-1] + fibs[i-2]
			    end
			    return fibs[n]
			  end
			end
			# この実装では、n が 0 の場合は 0 を返し、n が 1 の場合は 1 を返し、それ以外の場合は配列 fibs に最初の 2 つの値をセットし、forループで fibs[i] = fibs[i-1] + fibs[i-2] を繰り返し、最後に fibs[n] を返しています。

			③最後に、while文を使用する方法です。
			def fibonacci(n)
			  if n == 0
			    return 0
			  elsif n == 1
			    return 1
			  else
			    fibs = [0, 1]
			    i = 2
			    while i <= n
			      fibs[i] = fibs[i-1] + fibs[i-2]
			      i += 1
			    end
			    return fibs[n]
			  end
			end
			# この実装では、n が 0 の場合は 0 を返し、n が 1 の場合は 1 を返し、それ以外の場合は配列 fibs に最初の 2 つの値をセットし、whileループで fibs[i] = fibs[i-1] + fibs[i-2] を繰り返し、最後に fibs[n] を返しています。

			# 最も推奨される記述方法は、再帰関数を使用する方法です。再帰関数を使用することで、コードがシンプルになり、可読性が向上します。また、再帰関数は、フィボナッチ数列のような再帰的な処理を行う場合に最適な方法とされています。ただし、再帰関数はスタックオーバーフローを引き起こす可能性があるため、引数が大きくなる場合は注意が必要。
			
			③′ループを使用する方法（for文）
			def fibonacci(n)
			  if n == 0
			    return 0
			  elsif n == 1
			    return 1
			  else
			    fib1 = 0
			    fib2 = 1
			    for i in 2..n
			      fib = fib1 + fib2
			      fib1 = fib2
			      fib2 = fib
			    end
			    return fib2
			  end
			end

			# この方法では、最初に n が0または1の場合について処理を行います。それ以外の場合は、ループを使用してフィボナッチ数列を計算します。ループ内では、前回のフィボナッチ数とその前のフィボナッチ数を保存し、次のフィボナッチ数を計算するために使用します。最後に、fib2を返します。

			# この方法は、2番目の方法と同様に、再帰的な解法よりも効率的です。ただし、2番目の方法よりもわかりにくい場合があるため、最適な解法とは言えません。
			
